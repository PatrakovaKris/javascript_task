Чиним область видимости
Сейчас мы можем присвоить переменной значение только через define. 
Эта конструкция работает как при присвоении старым переменным, так и при создании новых. 
Эта неоднозначность приводит к проблемам. Если вы пытаетесь присвоить новое значение нелокальной переменной, 
вместо этого вы определяете локальную с таким же именем. 
(Некоторые языки так и делают, но мне это всегда казалось дурацким способом работы с областью видимости). 
Добавьте форму set, схожую с define, которая присваивает переменной новое значение, 
обновляя переменную во внешней области видимости, если она не задана в локальной. 
Если переменная вообще не задана, швыряйте ReferenceError (ещё один стандартный тип ошибки). 
Техника представления областей видимости в виде простых объектов, до сего момента бывшая удобной, 
теперь будет вам мешать. Вам может понадобиться функция Object.getPrototypeOf, возвращающая прототип объекта. 
Также помните, что область видимости не наследуется от Object.prototype, 
поэтому если вам надо вызвать на них hasOwnProperty, придётся использовать такую неуклюжую конструкцию: 
Object.prototype.hasOwnProperty.call(scope, name);   
Это вызывает метод hasOwnProperty прототипа Object и затем вызывает его на объекте scope.
   